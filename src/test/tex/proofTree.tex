\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{color}
\usepackage{xcolor}
\usepackage{bussproofs}
\usepackage{lscape}
\usepackage{listings}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\author{Mudathir Mahgoub}
\title{Type checker for System F}
\begin{document}

\maketitle

\section {Project Problem}

This project is a type checker for annotated simple typed lambda calculus and system F. It supports subtyping for simple types. In general, a type checker would decide whether $\Gamma \vdash t: T$ is derivable: can the term $t$ be assigned the type $T$ under the typing context $\Gamma$?

Section \ref{sec:software} describes the software and its architecture. Section \ref{sec:simple} describes the rules used for simple types and provides some examples. It also explains how subsumption rule can be delayed until variable terms are generated, and provides a proof for correctness. Section \ref{sec:simple} describes the rules used for system F and provides some examples.

\section{Software description} \label{sec:software}


\begin{figure}[h]
 \centering
 \includegraphics[scale=.25,keepaspectratio=true]{./typechecker.png}
 % gantt_chart.png: 0x0 pixel, 0dpi, nanxnan cm, bb=
 \caption{Project architecture.}
 \label{fig:gantt_chart}
\end{figure}

The project is implemented using Java and the executable is a jar file (TypeChecker.jar). The program receives as an input a text file containing subtypes definitions and a judgment to be checked. For testing JUnit5 was used to test the program directly without files. Below is an example of an input:

\definecolor{light-gray}{gray}{0.95}

\lstset{caption={test.txt},backgroundcolor= \color{light-gray}}

\begin{lstlisting}  
SubBase(bool, int);
. |- \lambda x. \lambda y. (x y)[bool]: (int ->T) -> (bool -> T);
\end{lstlisting}

Here is the output of the default printer.

\lstset{caption={java -jar TypeChecker.jar -i test.txt}}

\begin{lstlisting}  
Yes
                                SubBase(bool, int)
-------------------(var)        -------------------(subBase)
x: bool ? x : bool                      bool <: int
--------------------------------------(subsumption)
x: bool ? x : int

\end{lstlisting}

Here is the output of the latex printer

\lstset{caption={java -jar TypeChecker.jar -i test.txt -latex}}

\begin{lstlisting} 
Yes
 \begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var}
\UnaryInfC{$x: bool \vdash x : bool$}
\AxiomC{\scriptsize $SubBase(bool,int)$}
\RightLabel{\scriptsize subBase}
\UnaryInfC{$bool <: int$}
\RightLabel{\scriptsize subsumption}
\BinaryInfC{$x: bool \vdash x : int$}
\end{prooftree}

\end{lstlisting} 

\section{Simple types} \label{sec:simple}

\section{Rules} 

\begin{enumerate}

\item
\begin{prooftree}
\AxiomC{$\Gamma (x) = T$} \RightLabel{\scriptsize var} \UnaryInfC{$\Gamma \vdash x : T$}
\end{prooftree}
\item
\begin{prooftree}
\AxiomC{$\Gamma \vdash t_1 : T_1 \rightarrow T_2$} 
\AxiomC{$\Gamma \vdash t_2 : T_1$}
 \RightLabel{\scriptsize app} \BinaryInfC{$\Gamma \vdash (t_1 t_2)\color{blue}[T_1] \color{black} : T_2$}
\end{prooftree}
\item
\begin{prooftree}
\AxiomC{$\Gamma, x:T_1 \vdash t : T_2$} 
 \RightLabel{\scriptsize $\lambda$} \UnaryInfC{$\Gamma \vdash \lambda x .t:  T_1 \rightarrow T_2$}
\end{prooftree}

\item 

\begin{prooftree}
\AxiomC{$\Gamma \vdash t : T_1$} 
\AxiomC{$T_1 <: T_2$}
 \RightLabel{\scriptsize subsumption} \BinaryInfC{$\Gamma \vdash t: T_2$}
\end{prooftree}

\item 

\begin{prooftree}
\AxiomC{} 
 \RightLabel{\scriptsize reflexive} \UnaryInfC{$T <: T$}
\end{prooftree}
\item 

\begin{prooftree}
\AxiomC{$SubBase(b_1, b_2)$} 
 \RightLabel{\scriptsize subBase} \UnaryInfC{$b_1 <: b_2$}
\end{prooftree}
\item 

\begin{prooftree}
\AxiomC{$T'_1 <: T_1$} 
\AxiomC{$T_2 <: T'_2$}
 \RightLabel{\scriptsize arrow} \BinaryInfC{$T_1 \rightarrow T_2 <: T2_1 \rightarrow T'_2$}
\end{prooftree}

\item 

\begin{prooftree}
\AxiomC{$T_1 <: T_2$} 
\AxiomC{$T_2 <: T_3$}
 \RightLabel{\scriptsize transitive} \BinaryInfC{$T_1 <: T_3$}
\end{prooftree}


\end{enumerate}
\section{Variable terms}

\subsection{Valid}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: T \vdash x : T$}
\end{prooftree}

\subsection{Invalid}

\begin{prooftree}
\AxiomC{} \RightLabel{\color{red} \scriptsize invalid var} \UnaryInfC{$\cdot \vdash x : T$} \color{black} 
\end{prooftree}

\section{Lambda \& application terms}

\begin{prooftree}
\AxiomC{} \RightLabel{var} \UnaryInfC{$x: (T1 \rightarrow T2), y: T1 \vdash x : (T1 \rightarrow T2)$}
\AxiomC{} \RightLabel{var} \UnaryInfC{$x: (T1 \rightarrow T2), y: T1 \vdash y : T1$}
\RightLabel{app} \BinaryInfC{$x: (T1 \rightarrow T2), y: T1 \vdash (x\;y) [T1] : T2$}
\RightLabel{$\lambda$}\UnaryInfC{$x: (T1 \rightarrow T2) \vdash  \lambda y. (x\;y) [T1] : (T1 \rightarrow T2)$}
\RightLabel{$\lambda$}\UnaryInfC{$\cdot \vdash  \lambda x.  \lambda y. (x\;y) [T1] : ((T1 \rightarrow T2) \rightarrow (T1 \rightarrow T2))$}
\end{prooftree}


\section{Direct Subtyping}

\subsection{Valid}
\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: bool \vdash x : bool$}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: bool \vdash x : int$}
\end{prooftree}

\subsection{Invalid}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: int \vdash x : int$}
\AxiomC{\color{red} $\perp$ \color{black}} \RightLabel{\scriptsize \color{red} invalid \color{black}} \UnaryInfC{\color{red} $int <: bool$ \color{black}}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: int \vdash x : bool$}
\end{prooftree}


\section{Transitive Subtyping}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: bool \vdash x : bool$}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\AxiomC{\scriptsize SubBase($int,double)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$int <: double$}
\RightLabel{\scriptsize transitive} \BinaryInfC{$bool <: double$}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: bool \vdash x : double$}
\end{prooftree}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: bool \vdash x : bool$}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\AxiomC{\scriptsize SubBase($int,quotient)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$int <: quotient$}
\RightLabel{\scriptsize transitive} \BinaryInfC{$bool <: quotient$}
\AxiomC{\scriptsize SubBase($quotient,double)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$quotient <: double$}
\RightLabel{\scriptsize transitive} \BinaryInfC{$bool <: double$}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: bool \vdash x : double$}
\end{prooftree}

\section{Arrow Types}

\subsection{Valid}
\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: (int \rightarrow bool) \vdash x : (int \rightarrow bool)$}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\RightLabel{\scriptsize arrow} \BinaryInfC{$(int \rightarrow bool) <: (bool \rightarrow int)$}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: (int \rightarrow bool) \vdash x : (bool \rightarrow int)$}
\end{prooftree}

\subsubsection{Reflexive}
\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: (int \rightarrow bool) \vdash x : (int \rightarrow bool)$}
\AxiomC{} \RightLabel{\scriptsize reflexive} \UnaryInfC{$int <: int$}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\RightLabel{\scriptsize arrow} \BinaryInfC{$(int \rightarrow bool) <: (int \rightarrow int)$}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: (int \rightarrow bool) \vdash x : (int \rightarrow int)$}
\end{prooftree}

\subsubsection{Nested}

\tiny
\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: (int \rightarrow T), y: bool \vdash x : (int \rightarrow T)$}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\AxiomC{} \RightLabel{\scriptsize reflexive} \UnaryInfC{$T <: T$}
\RightLabel{\scriptsize arrow} \BinaryInfC{$(int \rightarrow T) <: (bool \rightarrow T)$}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: (int \rightarrow T), y: bool \vdash x : (bool \rightarrow T)$}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: (int \rightarrow T), y: bool \vdash y : bool$}
\RightLabel{\scriptsize app} \BinaryInfC{$x: (int \rightarrow T), y: bool \vdash (x\;y) [bool] : T$}
\RightLabel{$\lambda$}\UnaryInfC{$x: (int \rightarrow T) \vdash  \lambda y. (x\;y) [bool] : (bool \rightarrow T)$}
\RightLabel{$\lambda$}\UnaryInfC{$\cdot \vdash  \lambda x.  \lambda y. (x\;y) [bool] : ((int \rightarrow T) \rightarrow (bool \rightarrow T))$}
\end{prooftree}

\normalsize

\subsection{Invalid}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: (bool \rightarrow bool) \vdash x : (bool \rightarrow bool)$}
\AxiomC{\color{red} $\perp$ \color{black}} \RightLabel{\scriptsize \color{red} invalid \color{black}} \UnaryInfC{\color{red} $int <: bool$ \color{black}}
\AxiomC{\scriptsize SubBase($bool,int)$} \RightLabel{\scriptsize subBase} \UnaryInfC{$bool <: int$}
\RightLabel{\scriptsize arrow} \BinaryInfC{$(bool \rightarrow bool) <: (int \rightarrow int)$}
\RightLabel{\scriptsize subsumption} \BinaryInfC{$x: (bool \rightarrow bool) \vdash x : (int \rightarrow int)$}
\end{prooftree}

\fontsize{4.2}{4}

\begin{prooftree}
\AxiomC{} \RightLabel{\tiny var} \UnaryInfC{$x: (bool \rightarrow T), y: bool \vdash x : (bool \rightarrow T)$}
\AxiomC{\color{red} $\perp$ \color{black}} \RightLabel{\tiny \color{red} invalid \color{black}} \UnaryInfC{\color{red} $int <: bool$ \color{black}}
\AxiomC{} \RightLabel{\tiny reflexive} \UnaryInfC{$T <: T$}
\RightLabel{\tiny arrow} \BinaryInfC{$(bool \rightarrow T) <: (int \rightarrow T)$}
\RightLabel{\tiny subsumption} \BinaryInfC{$x: (bool \rightarrow T), y: bool \vdash x : (int \rightarrow T)$}
\AxiomC{} \RightLabel{\tiny var} \UnaryInfC{$x: (bool \rightarrow T), y: bool \vdash y : bool$}
\AxiomC{\tiny SubBase($bool,int)$} \RightLabel{\tiny subBase} \UnaryInfC{$bool <: int$}
\RightLabel{\tiny subsumption} \BinaryInfC{$x: (bool \rightarrow T), y: bool \vdash y : int$}
\RightLabel{\tiny app} \BinaryInfC{$x: (bool \rightarrow T), y: bool \vdash (x\;y) [int] : T$}
\RightLabel{$\lambda$}\UnaryInfC{$x: (bool \rightarrow T) \vdash  \lambda y. (x\;y) [int] : (bool \rightarrow T)$}
\RightLabel{$\lambda$}\UnaryInfC{$\cdot \vdash  \lambda x.  \lambda y. (x\;y) [int] : ((bool \rightarrow T) \rightarrow (bool \rightarrow T))$}
\end{prooftree}

\normalsize

\subsection{Delaying applying the subsumption rule}

The sumbumption rule can be delayed until the term in the judgment is a just a variable. This simplifies the code since there is only one rule to be applied for application and $\lambda$ abstraction terms. Here is the correctness proof. 


\begin{prooftree}
\AxiomC{$\Gamma \vdash t : T$} 
\AxiomC{$T <: T'$}
 \RightLabel{\scriptsize subsumption} \BinaryInfC{$\Gamma \vdash t: T'$}
\end{prooftree}


\textbf{Proof:}

By induction hypothesis on the structure of the term. 

\begin{enumerate}
\item Case $t=x$: trivial since $t$ is a variable. 

\begin{prooftree}
\AxiomC{$\Gamma \vdash x : T$} 
\AxiomC{$T <: T'$}
 \RightLabel{\scriptsize subsumption} \BinaryInfC{$\Gamma \vdash x: T'$}
\end{prooftree}

\item Case $t=t_1 t_2$: assume $T_2 <: T'_2$ and the following derivation:

\begin{prooftree}
\AxiomC{$\Gamma \vdash t_1 : T_1 \rightarrow T_2$} 
\AxiomC{$\Gamma \vdash t_2 : T_1$} 
\RightLabel{\scriptsize app}
\BinaryInfC{$\Gamma \vdash t_1 t_2 [T_1] : T_2$} 
\AxiomC{$T_2 <: T'_2$}
\RightLabel{\scriptsize subsumption} 
\BinaryInfC{$\Gamma \vdash t_1 t_2 [T_1]: T_2'$}
\end{prooftree}

We can get a different derivation tree where the sumbsumption rule is delayed:

\begin{prooftree}
\AxiomC{$\Gamma \vdash t_1 t_2 [T_1] : T_2$} 
\AxiomC{} 
\RightLabel{\scriptsize reflexive}
\UnaryInfC{$T_1 <: T_1$} 
\AxiomC{$T_2 <: T'_2$}
\RightLabel{\scriptsize arrow}
\BinaryInfC{$T_1 \rightarrow T_2 <: T_1 \rightarrow T'_2$}
\RightLabel{\scriptsize subsumption}
\BinaryInfC{$\Gamma \vdash t_1 : T_1 \rightarrow T'_2$} 
\AxiomC{$\Gamma \vdash t_2 : T_1$} 
\RightLabel{\scriptsize app} 
\BinaryInfC{$\Gamma \vdash t_1 t_2 [T_1]: T'_2$}
\end{prooftree}

By the induction hypothesis, the subsumption rule can be delayed until  variable terms are generated in the derivation of 
$\Gamma \vdash t_1 : T_1 \rightarrow T'_2$ and $\Gamma \vdash t_2 : T_1$.

\item Case $t=\lambda x. t'$: assume $T_1 \rightarrow T_2 <: T'_1 \rightarrow T'_2$ and the following derivation:

\begin{prooftree}
\AxiomC{$\Gamma, x:  T_1 \vdash t': T_2$} 
\RightLabel{\scriptsize $\lambda$}
\UnaryInfC{$\Gamma \vdash \lambda x. t': T_1 \rightarrow T_2$} 
\AxiomC{$T'_1 <: T_1$} 
\AxiomC{$T_2 <: T'_2$}
\RightLabel{\scriptsize arrow} 
\BinaryInfC{$T_1 \rightarrow T_2 <: T'_1 \rightarrow T'_2$}
\RightLabel{\scriptsize subsumption} 
\BinaryInfC{$\Gamma \vdash \lambda x. t': T'_1 \rightarrow T'_2$}
\end{prooftree}


Alternatively we can derive:


\begin{prooftree}
\AxiomC{$\Gamma, x: T'_1  \vdash t':  T_2$} 
\AxiomC{$T_2 <: T'_2$}
\RightLabel{\scriptsize subsumption} 
\BinaryInfC{$\Gamma, x: T'_1  \vdash t':  T'_2$} 
\RightLabel{\scriptsize $\lambda$} 
\UnaryInfC{$\Gamma \vdash \lambda x. t': T'_1 \rightarrow T'_2$}
\end{prooftree}

Since $T'_1 <: T_1$ then by the subsumption rule:
\begin{prooftree}
\AxiomC{}
\RightLabel{\scriptsize var} 
\UnaryInfC{$\Gamma, x: T'_1 \vdash  x : T'_1 $}
\AxiomC{$T'_1 <: T_1$}
\RightLabel{\scriptsize subsumption} 
\BinaryInfC{$\Gamma, x: T'_1 \vdash  x : T_1 $}
\end{prooftree}

Therefore if $\Gamma, x: T_1  \vdash t':  T_2$ then $\Gamma, x: T'_1  \vdash t':  T_2$ which concludes the proof. 

\textbf{Note}:

If $\Gamma, x: T'_1  \vdash t':  T_2$, it is not always true  that $\Gamma, x: T_1  \vdash t':  T_2$ where $T'_1 <: T_1$. A counter example would be 
\begin{align*}
x: bool \vdash x: int \nRightarrow x:double \vdash x: int,\;\;\; bool <: int <: double
\end{align*}
However 
\begin{align*}
x: int \vdash x: double \Rightarrow x:bool \vdash x: double,\;\;\; bool <: int <: double
\end{align*}

Therefore in the following example, using the subsumption rule first would fail and slow the type checker because it needs to backtrack and check the $\lambda$ rule. However using the subsumption rule would prove the type checking and is faster. 


\begin{prooftree}
\AxiomC{\color{red} $\ x:  double \vdash x: int$ \color{black}} 
\RightLabel{\scriptsize $\lambda$}
\UnaryInfC{$\Gamma \vdash \lambda x. x: double \rightarrow int$} 
\AxiomC{$SubBase(bool, double)$}
\RightLabel{\scriptsize subBase} 
\UnaryInfC{$bool <: double$} 
\AxiomC{}
\RightLabel{\scriptsize reflexive} 
\UnaryInfC{$int <: int$}
\RightLabel{\scriptsize arrow} 
\BinaryInfC{$double \rightarrow int <: bool \rightarrow int$}
\RightLabel{\scriptsize subsumption} 
\BinaryInfC{$\Gamma \vdash \lambda x. x: bool \rightarrow int$}
\end{prooftree}



\begin{prooftree}
\AxiomC{} 
\RightLabel{\scriptsize var} 
\UnaryInfC{$\Gamma, x: bool \vdash x:  bool$} 
\AxiomC{$SubBase(bool, int)$} 
\RightLabel{\scriptsize suBase} 
\UnaryInfC{$bool <: int$}
\RightLabel{\scriptsize subsumption} 
\BinaryInfC{$\Gamma, x: bool  \vdash x:  int$} 
\RightLabel{\scriptsize $\lambda$} 
\UnaryInfC{$\Gamma \vdash \lambda x. x: bool \rightarrow int$}
\end{prooftree}


\end{enumerate}


\section{System F} \label{sec:systemF}

\subsection{Variables}



\subsubsection{Valid}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.X \vdash x : \forall X.X$}
\end{prooftree}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.X \vdash x : \forall Y.Y$}
\end{prooftree}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.(X \rightarrow X) \vdash x : \forall Y.(Y \rightarrow Y)$}
\end{prooftree}

$Y$ is free in the context and the type:

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.(X \rightarrow Y) \vdash x : \forall Z.(Z \rightarrow Y)$}
\end{prooftree}


\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.X \vdash x : \forall X1.X1$}
\RightLabel{\scriptsize elimination}\UnaryInfC{$x: \forall X.X \vdash x[Y] : Y$}
\end{prooftree}

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.X \vdash x : \forall X1.X1$}
\RightLabel{\scriptsize elimination}\UnaryInfC{$x: \forall X.X \vdash x[(Y \rightarrow Y)] : (Y \rightarrow Y)$}
\end{prooftree}

\tiny
\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.X \vdash x : \forall X1.X1$}
\RightLabel{\scriptsize elimination}\UnaryInfC{$x: \forall X.X \vdash x[[(\forall X.X \rightarrow \forall X.X)]][(\forall X.X \rightarrow \forall X.X)] : (\forall X.X \rightarrow \forall X.X)$}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.X \vdash x : \forall X.X$}
\RightLabel{\scriptsize app} \BinaryInfC{$x: \forall X.X \vdash (x[[(\forall X.X \rightarrow \forall X.X)]]\;x) [\forall X.X] : \forall X.X$}
\end{prooftree}

\normalsize

\subsubsection{Invalid}

$Y$ is free in the context:

\begin{prooftree}
\AxiomC{} \RightLabel{\color{red} \scriptsize invalid var} \UnaryInfC{$x: \forall X.(X \rightarrow Y) \vdash x : \forall Y.(Y \rightarrow Y)$} \color{black} 
\end{prooftree}

$Y$ is free in the context, and $Z$ is free in the type: 

\begin{prooftree}
\AxiomC{} \RightLabel{\color{red} \scriptsize invalid var} \UnaryInfC{$x: \forall X.(X \rightarrow Y) \vdash x : \forall Y.(Y \rightarrow Z)$} \color{black} 
\end{prooftree}


\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$x: \forall X.X \vdash x : \forall X1.X1$}
\RightLabel{\scriptsize elimination}\UnaryInfC{$x: \forall X.X \vdash x[Y] : Y$}
\end{prooftree}


\subsection{Numbers}

Zero
\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var} \UnaryInfC{$z: X, s: (X \rightarrow X) \vdash z : X$}
\RightLabel{$\lambda$}\UnaryInfC{$s: (X \rightarrow X) \vdash (\lambda z. z) : (X \rightarrow X)$}
\RightLabel{$\lambda$}\UnaryInfC{$\cdot \vdash (\lambda s. (\lambda z. z)) : ((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\RightLabel{\scriptsize introduction}\UnaryInfC{$\cdot \vdash (\lambda s. (\lambda z. z)) : \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\end{prooftree}

Zero with free variable $X$

\begin{prooftree}
\AxiomC{} \RightLabel{\scriptsize var}
\UnaryInfC{$y: X, z: X_2, s: (X_2 \rightarrow X_2) \vdash z : X_2$}
\RightLabel{$\lambda$}
\UnaryInfC{$y: X, s: (X_2 \rightarrow X_2) \vdash (\lambda z. z) : (X_2 \rightarrow X_2)$}
\RightLabel{$\lambda$}
\UnaryInfC{$y: X \vdash (\lambda s. (\lambda z. z)) : ((X_2 \rightarrow X_2) \rightarrow (X_2 \rightarrow X_2))$}
\RightLabel{\scriptsize introduction}
\UnaryInfC{$y: X \vdash (\lambda s. (\lambda z. z)) : \forall X_2.((X_2 \rightarrow X_2) \rightarrow (X_2 \rightarrow X_2))$}
\RightLabel{\scriptsize renaming}
\UnaryInfC{$y: X \vdash (\lambda s. (\lambda z. z)) : \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\end{prooftree}


\begin{landscape}

Successor missing annotation
\fontsize{3}{4}
\begin{prooftree}
\AxiomC{} \RightLabel{\tiny var}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash s : (X \rightarrow X)$}
\AxiomC{}
\RightLabel{\color{blue} \tiny unknown}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash n : ((X \rightarrow X) \rightarrow (X \rightarrow X))$ \color{black}}  
\AxiomC{} \RightLabel{\tiny var}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash s : (X \rightarrow X)$}
\RightLabel{\tiny app}
\BinaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash (n\;s) [(X \rightarrow X)] : (X \rightarrow X)$}
\AxiomC{} \RightLabel{\tiny var}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash z : X$}
\RightLabel{\tiny app}
\BinaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash ((n\;s) [(X \rightarrow X)]\;z) [X] : X$}
\RightLabel{\tiny app}
\BinaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash (s\;((n\;s) [(X \rightarrow X)]\;z) [X]) [X] : X$}
\RightLabel{$\lambda$}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), s: (X \rightarrow X) \vdash (\lambda z. (s\;((n\;s) [(X \rightarrow X)]\;z) [X]) [X]) : (X \rightarrow X)$}
\RightLabel{$\lambda$}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)) \vdash (\lambda s. (\lambda z. (s\;((n\;s) [(X \rightarrow X)]\;z) [X]) [X])) : ((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\RightLabel{\tiny introduction}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)) \vdash (\lambda s. (\lambda z. (s\;((n\;s) [(X \rightarrow X)]\;z) [X]) [X])) : \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\RightLabel{$\lambda$}
\UnaryInfC{$\cdot \vdash (\lambda n. (\lambda s. (\lambda z. (s\;((n\;s) [(X \rightarrow X)]\;z) [X]) [X]))) : (\forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)) \rightarrow \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)))$}
\end{prooftree}

\normalsize
Successor well annotated

\fontsize{3}{4}



\begin{prooftree}
\AxiomC{} \RightLabel{\tiny var}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash s : (X \rightarrow X)$}
\AxiomC{} \RightLabel{\tiny var}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash n : \forall X1.((X1 \rightarrow X1) \rightarrow (X1 \rightarrow X1))$}
\RightLabel{\tiny elimination}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash n[[X]][X] : ((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\AxiomC{} \RightLabel{\tiny var}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash s : (X \rightarrow X)$}
\RightLabel{\tiny app}
\BinaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash (n[[X]]\;s) [(X \rightarrow X)] : (X \rightarrow X)$}
\AxiomC{} \RightLabel{\tiny var}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash z : X$}
\RightLabel{\tiny app}
\BinaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash ((n[[X]]\;s) [(X \rightarrow X)]\;z) [X] : X$}
\RightLabel{\tiny app}
\BinaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), z: X, s: (X \rightarrow X) \vdash (s\;((n[[X]]\;s) [(X \rightarrow X)]\;z) [X]) [X] : X$}
\RightLabel{$\lambda$}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)), s: (X \rightarrow X) \vdash (\lambda z. (s\;((n[[X]]\;s) [(X \rightarrow X)]\;z) [X]) [X]) : (X \rightarrow X)$}
\RightLabel{$\lambda$}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)) \vdash (\lambda s. (\lambda z. (s\;((n[[X]]\;s) [(X \rightarrow X)]\;z) [X]) [X])) : ((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\RightLabel{\tiny introduction}
\UnaryInfC{$n: \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)) \vdash (\lambda s. (\lambda z. (s\;((n[[X]]\;s) [(X \rightarrow X)]\;z) [X]) [X])) : \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X))$}
\RightLabel{$\lambda$}
\UnaryInfC{$\cdot \vdash (\lambda n. (\lambda s. (\lambda z. (s\;((n[[X]]\;s) [(X \rightarrow X)]\;z) [X]) [X]))) : (\forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)) \rightarrow \forall X.((X \rightarrow X) \rightarrow (X \rightarrow X)))$}
\end{prooftree}

\end{landscape}

\end{document}
